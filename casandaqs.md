- 锁
    - 悲观锁：写多，读少。采用LOCK
    - 乐观锁：写少，读多。采用版本机制。每写一次版本增加
- CAS：CompareAndSwap
    - 一种无锁的原子算法，乐观锁。给一个期望值，与现有的值比较，如果相等再修改，不相等什么都不做
    CAS(V,E,N)：V是拿到的值，E期望的值，N要修改的值。如果V=E才会将V的值修改成N。如果V!=E则说明已经被人修改，不做操作
    - CAS实现稍微复杂，无锁，不存在阻塞，提高效率，CPU的吞吐量。
    - CAS是靠硬件实现的，从而在硬件层面提升效率。
    - JUC下的atomic类都是通过CAS来实现的
    
- CAS缺点
    - 循环时间太长：如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。
    - 只能保证一个共享变量原子操作：看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位
    - ABA问题：CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —> B —> A，变成1A —> 2B —> 3A。
- thread.Join()：把该线程加入到当前线程，比如main中走到thread.Join()时会先执行thread完毕后再执行main


- AQS：AbstractQueuedSychronizer同步发生器，构建LOCK。在JUC包ReentrantLock、读写锁、信号量的基础都是AQS    
    - 通过内置得到FIFO同步队列来完成线程争夺资源的管理工作
    - 同步器来管理 需要获取资源的Node线程队列，每个线程做的事情就是获取锁、释放锁，然后队列里的线程通过自旋锁去公平竞争资源