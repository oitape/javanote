- LinkedBlockingQueue:链表阻塞队列
    ![](/assets/iShot2020-09-15下午04.53.45.png)
    - queue是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口有三大类操作：
        - 新增操作
            - add队列满了抛出异常
            - offer队列满了返回false
        - 查看并删除
            - remove队列空的时候抛异常
            - poll队列空的时候返回null
        - 查看不删除
            - element队列空的时候抛异常
            - peek队列空的时候返回null
    - 类信息
        - 基于链表的阻塞队列
        - 链表维护先入先出队列，新元素放在队尾，获取元素从队头部拿
        - 链表大小再初始化的时候可以设置，默认Integer最大值
        - 可以使用Collection和Iterator接口的所有操作
    - 新增: add、put、offer
        - 第一步上锁ReentrantLock，新增是线程安全的
        - 队列新增数据，简单追加到链表尾部
        - put方法新增，如果队列满了当前线程会一直被阻塞的，阻塞的底层使用是锁的能力，
        - 新增数据成功后，在适当时机会唤起put的等待线程（队列不满时），或者take的等待线程
        - offer方法阻塞超过一段时间后，仍未成功，就会直接返回默认值的实现
        

- SynchronousQueue： 
    - 队列模式：TransferQueue
        - 队列不存储数据，所以没有大小，也无法迭代
        - 插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然
        - 队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的堆栈，堆栈非公平的，队列公平的
        - 初始化时无参默认使用的就是堆栈的，堆栈的效率比队列的更高
    - 堆栈模式：TransferStack
        - put放到堆栈头
        - take从堆栈头拿
        
- DelayQueue：延迟队列
    - 队列中元素将在过期时执行，越靠近队头，越早过期
    - 未过期的元素不能被take
    - 不允许空元素
    - 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的    
    - 底层使用排序和超时阻塞实现延迟队列，排序使用PriorityQueue排序能力，超时阻塞使用的是锁的等待能力。





