- LinkedBlockingQueue:链表阻塞队列
    ![](/assets/iShot2020-09-15下午04.53.45.png)
    - queue是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口有三大类操作：
        - 新增操作
            - add队列满了抛出异常
            - offer队列满了返回false
        - 查看并删除
            - remove队列空的时候抛异常
            - poll队列空的时候返回null
        - 查看不删除
            - element队列空的时候抛异常
            - peek队列空的时候返回null
    - 类信息
        - 基于链表的阻塞队列
        - 链表维护先入先出队列，新元素放在队尾，获取元素从队头部拿
        - 链表大小再初始化的时候可以设置，默认Integer最大值
        - 可以使用Collection和Iterator接口的所有操作
    - 新增: add、put、offer
        - 第一步上锁ReentrantLock，新增是线程安全的
        - 队列新增数据，简单追加到链表尾部
        - put方法新增，如果队列满了当前线程会一直被阻塞的，阻塞的底层使用是锁的能力，
        - 新增数据成功后，在适当时机会唤起put的等待线程（队列不满时），或者take的等待线程
        - offer方法阻塞超过一段时间后，仍未成功，就会直接返回默认值的实现
        

- SynchronousQueue： 
    - 队列模式：TransferQueue
        - 队列不存储数据，所以没有大小，也无法迭代
        - 插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然
        - 队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的堆栈，堆栈非公平的，队列公平的
        - 初始化时无参默认使用的就是堆栈的，堆栈的效率比队列的更高
    - 堆栈模式：TransferStack
        - put放到堆栈头
        - take从堆栈头拿
        
- DelayQueue：延迟队列
    - 队列中元素将在过期时执行，越靠近队头，越早过期
    - 未过期的元素不能被take
    - 不允许空元素
    - 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的    
    - 底层使用排序和超时阻塞实现延迟队列，排序使用PriorityQueue排序能力，超时阻塞使用的是锁的等待能力。


- ArrayBlockingQueue:
    - 有界的阻塞数组，容量一旦创建，后续大小无法修改
    - 不允许空元素
    - 元素是有顺序的，按照先进先出进行排序，队尾插入，队头拿数据
    - 队列满时，继续put会被阻塞，队列空时取数据，take会被阻塞
    - 构造函数有fair入参时，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，非公平锁，锁竞争时随机的。
    
- 哪些队列具有阻塞功能，大概如何阻塞？
    - LinkedBlockingQueue和ArrayBlockingQueue是异类，前者容量是Integer的最大值。后者数组大小固定，两个阻塞都可以指定大小，当队列满时，如果有线程put就会阻塞，直到其他线程消费数据后，才会唤醒阻塞线程继续put，当队列为空时，如果有线程take数据，线程会阻塞到队列不空时
    - SynchronousQueue同步队列，当线程put时，必须有对应线程数据消费掉，put线程才能返回，当线程take时，需要有对应线程进行put数据，take才能返回
    - 队列本身并没有实现阻塞功能，而是利用Confition的等待唤醒机制，阻塞底层实现就是更改线程的状态为沉睡。

- put和take都会加锁，是不是同一时刻只能运行其中一个方法？
    - 对于 LinkedBlockingQueue 来说，队列的 put 和 take 都会加锁， 但两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于 ArrayBlockingQueue 而 言，put 和 take 是同一个锁，所以同一时刻只能运行一个方法。
    
- 工作中经常使用队列的 put、take 方法有什么危害，如何避免？
    - put和take，当出现阻塞时会一直阻塞到 队列有数据或者不满为止，两个方法都是无限(永远、没有超时时间的意思)阻塞的方法，容易使得线程全部都阻塞住，大流量时容易导致机器无线程可用，所以建议在流量大时，使用offer和poll方法来代替两者，只需要设置好超时阻塞时间，如果在超时时间内还没有返回，就会返回默认值，就不会导致所有的线程都阻塞住。

- SynchronousQueue队列有没有大小？
    - SynchronousQueue本身没有容量的，所以无法查看其大小
    
    
    
