- 内存区域划分
 - 方法区：类信息、常量、static、JIT即时编译的代码 （信息共享）
 - 堆区： 实例对象 （GC管理的区域）
 - stack区：Java方法在运行的内存模型，每一个方法都有自己的栈帧：局部变量、引用类型数据的地址、操作数栈
 - PC区：Java线程的私有数据：执行下一条指令的地址
 - Native method stack：虚拟机的native方法有关
- 内存模型：JMM（Java memory model）
 - 主内存（共享内存）：
 - 工作空间内存
 - 工作方式：
   - 线程修改私有数据，直接在工作空间上修改
   - 线程修改共享数据，把数据复制到工作空间中去，在工作空间中修改，修改完成以后，刷新内存中的数据
 
 - JMM的必要性：规范内存数据和工作空间数据的交互

- 硬件内存架构和JMM模型
 CPU先去寄存器中取，取不到到缓存中取，再取不到到内存中取
![](/assets/图片 1.png)
 - CPU缓存的一致性问题：并发处理的不同步
   解决方案：
    - 总线加锁 降低CPU的吞吐量
    - 缓存上的一致性协议（MESI）
      当CPU在CACHE中操作数据时，如果该数据是共享变量，数据在CACHE读到寄存器中，进行新修改，并更新内存数据，CaCHE LINE置无效，其他的CPU就从内存中读数据

- 并发编程的三个重要特性
 - 原子性：不可分割  x=1
 - 可见性：线程只能操作自己工作空间中的数据
 - 有序性：程序中的顺序不一定就是执行的顺序，提高效率
     - 编译重排序
     - 指令重排序
   ```java
   /*
   * as-if-seria:单线程中重排后不影响执行的结果，多线程。
   * happens-before
   * /
   ```
- JMM对三个特征的保证
 - X=10,写 原子性。如果是私有数据具有原子性，共享数据没原子性
 - Y=x 没有原子性。先把数据X读到工作空间，把X的值写到Y
 - i++ 没有原子性，读i到工作空间；+1；刷新结果到内存
 
- JMM可见性
 - Volatile在JMM模型上实现MESI协议，
 - Synchronize：加锁
 - JUC Lock
- JMM与有序性
 - Volatile：
 - Synchronized：
 - Happens-before原则：
   - 程序次序原则
   - 锁定原则：后一次加锁必须等前一次解锁
   - Volatile原则：霸道原则
   - 传递原则：A---B---C       A--C

