## 基本概念
- Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。
- 不只是专用于Java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。 比如kotlin、scala等。
    
### JVM基本结构
- 类加载子系统
- 运行时数据区（内存结构）
- 执行引擎
![](/assets/jvm.png)

### 运行时数据区
- 方法区(Method Area)
    - 类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在这里定义。所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟 机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是为了和Java的 堆区分开

- 堆(Heap)			
    - 使用new创建的对象，定义的数组都存在堆区。垃圾回收机制算法、jvm参数调优、内存溢出和内存泄漏等都是在堆内存中进行操作。
    - 堆内存划分：新生代和老生代，
        - 新生代伊甸区(Eden space)和幸存者区(Survivor space)，所有的类都是在伊甸区被new出来的，幸存区又分为From和To区，当Eden区的空间用完是，程序又需要创建对象，JVM的垃圾回收器将Eden区进行垃圾回 收(Minor GC)，将Eden区中的不再被其它对象应用的对象进行销毁。然后将Eden区中剩余的对象移到From Survivor区。若From Survivor区也满了，再对该区进行垃圾回收，然后移动到To Survivor区。
        - Eden:from:to = 8:1:1
        - 新老默认内存比例1：2。
        - 新生代：刚出生不久的对象，存放在新生代里面；存放不是经常使用的对象。
        - 老生代：新生代经过多次GC仍然存货的对象移动到老年区。若老年代也满了，这时候将发生Major GC(也可以叫Full GC)， 进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会抛出OOM(OutOfMemoryError)异常，存放比较活跃的对象；存放经常被引用对象。
    - 元空间(Meta Space)
        - JDK1.8之后，元空间替代了永久代，它是对JVM规范中方法区的实现，区别在于元数据区不在虚拟机当中，而是用的本地内存，永久代在虚拟机当中，永久代逻辑结构上也属于堆，但是物理上不属于。

### 栈(Stack)
- Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧(用于存储局部变量 表，操作数栈，动态链接，方法出口等信息)不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致

### 本地方法栈(Native Method Stack) 
- 和栈作用很相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行native方法服务。登记native方法，在Execution Engine执行时加载本地方法库

### 程序计数器(Program Counter Register)
- 就是一个指针，指向方法区中的方法字节码(用来存储指向吓一跳指令的地址，也即将要执行的指令代码)，由执行 引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计

### 垃圾回收机制
- JVM不定时的回收不可达的对象（对象未被引用）
```java
///提示给gc进行回收垃圾，但不代表立即进行回收。gc线程是守护线程
	System.gc();
	
	///垃圾回收之前会执行的方法
	protected void finalize() throws Throwable {
		super.finalize();
}
```